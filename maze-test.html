<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>迷宫游戏测试 - 防卡死版本</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .test-container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-info {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .test-button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        .test-button:hover {
            background: #1976D2;
        }
        .test-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
        }
        .status.success {
            background: #c8e6c9;
            color: #2e7d32;
        }
        .status.warning {
            background: #fff3e0;
            color: #f57c00;
        }
        .status.error {
            background: #ffcdd2;
            color: #c62828;
        }
        .maze-display {
            border: 1px solid #ddd;
            margin: 20px 0;
            padding: 20px;
            text-align: center;
        }
        canvas {
            border: 1px solid #ccc;
            max-width: 100%;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>迷宫游戏测试 - 防卡死版本</h1>
        
        <div class="test-info">
            <h3>修复内容：</h3>
            <ul>
                <li>限制迷宫最大尺寸为35x35</li>
                <li>移除递归分割算法（容易栈溢出）</li>
                <li>移除极限复杂度和移动墙壁功能</li>
                <li>添加算法迭代次数限制</li>
                <li>添加5秒超时保护</li>
                <li>使用requestAnimationFrame避免阻塞UI</li>
                <li>优化迷宫生成算法</li>
                <li><strong>新增：统一迷宫生成框架，确保算法兼容性</strong></li>
                <li><strong>新增：自动路径确保，起点到终点100%可达</strong></li>
                <li><strong>新增：基础网格结构，防止算法冲突</strong></li>
            </ul>
        </div>

        <div class="maze-display">
            <h3>迷宫生成测试</h3>
            <div>
                <label>迷宫大小: 
                    <select id="maze-size">
                        <option value="15">15x15 (简单)</option>
                        <option value="21">21x21 (中等)</option>
                        <option value="25">25x25 (困难)</option>
                        <option value="31">31x31 (专家)</option>
                        <option value="35">35x35 (大师)</option>
                    </select>
                </label>
                <label>算法: 
                    <select id="maze-algorithm">
                        <option value="dfs">深度优先搜索</option>
                        <option value="prim">Prim算法</option>
                        <option value="kruskal">Kruskal算法</option>
                        <option value="binary">二叉树算法</option>
                    </select>
                </label>
                <label>复杂度: 
                    <select id="maze-complexity">
                        <option value="simple">简单</option>
                        <option value="normal">普通</option>
                        <option value="complex">复杂</option>
                    </select>
                </label>
            </div>
            <div style="margin: 15px 0;">
                <button id="generate-btn" class="test-button">生成迷宫</button>
                <button id="test-large-btn" class="test-button">测试大迷宫 (35x35)</button>
                <button id="test-complex-btn" class="test-button">测试复杂算法</button>
            </div>
            <div id="status" class="status"></div>
                    <div style="margin: 10px 0; padding: 10px; background: #f0f0f0; border-radius: 5px;">
            <strong>玩家位置:</strong> <span id="player-pos">(1, 1)</span> | 
            <strong>控制方式:</strong> 方向键/WASD | 鼠标点击 | 鼠标拖拽
        </div>
            <canvas id="maze-canvas" width="400" height="400"></canvas>
        </div>

        <div class="test-info">
            <h3>测试说明：</h3>
            <p>1. 选择不同的迷宫大小和算法进行测试</p>
            <p>2. 观察生成时间和是否出现卡死现象</p>
            <p>3. 如果5秒内未完成生成，会自动超时</p>
            <p>4. 大迷宫(35x35)应该能在合理时间内完成</p>
            <p>5. <strong>新：使用统一生成框架，所有算法都能正常生成可玩迷宫</strong></p>
            <p>6. <strong>新：自动路径确保，起点到终点100%可达</strong></p>
            <p>7. <strong>新：基础网格结构，防止算法混合导致的路径问题</strong></p>
            <p>8. <strong>新：鼠标控制支持，点击移动和拖拽路径预览</strong></p>
        </div>
        
        <div class="test-info">
            <h3>鼠标控制说明：</h3>
            <p><strong>点击移动：</strong> 直接点击迷宫中的任意可达位置，玩家会立即移动到该位置</p>
            <p><strong>拖拽移动：</strong> 从玩家当前位置开始拖拽，会显示黄色路径预览，释放鼠标后沿路径移动</p>
            <p><strong>触摸支持：</strong> 在移动设备上支持触摸拖拽操作</p>
            <p><strong>路径验证：</strong> 系统会自动检查路径是否可达，不可达的路径会移动失败</p>
        </div>
    </div>

    <script>
        class SimpleMazeGenerator {
            constructor() {
                this.size = 15;
                this.maze = [];
                this.canvas = null;
                this.ctx = null;
                this.generationTimeout = null;
                this.maxGenerationTime = 5000;
                this.player = { x: 1, y: 1 };
            }

            init() {
                this.canvas = document.getElementById('maze-canvas');
                this.ctx = this.canvas.getContext('2d');
            }

            generateMaze() {
                const startTime = Date.now();
                
                // 限制迷宫大小
                if (this.size > 35) {
                    this.size = 35;
                    console.warn('迷宫大小已限制为35x35');
                }

                // 使用统一的迷宫生成方法
                this.generateUnifiedMaze();
                
                const endTime = Date.now();
                console.log(`迷宫生成完成，耗时: ${endTime - startTime}ms`);
                
                this.drawMaze();
            }
            
            // 统一的迷宫生成方法
            generateUnifiedMaze() {
                // 初始化迷宫，所有奇数位置为路径，偶数位置为墙壁
                this.maze = Array(this.size).fill().map(() => Array(this.size).fill(1));
                
                // 先创建基础网格结构
                for (let y = 1; y < this.size - 1; y += 2) {
                    for (let x = 1; x < this.size - 1; x += 2) {
                        this.maze[y][x] = 0; // PATH
                    }
                }
                
                // 生成迷宫
                this.generateDFS();
                
                // 设置起点和终点
                this.maze[1][1] = 2; // START
                this.maze[this.size - 2][this.size - 2] = 3; // END
                
                // 确保起点到终点有路径
                this.ensureStartEndPath();
            }
            
            // 确保起点到终点有路径
            ensureStartEndPath() {
                // 创建一条从起点到终点的L形路径
                const startX = 1, startY = 1;
                const endX = this.size - 2, endY = this.size - 2;
                
                // 水平路径
                for (let x = startX; x <= endX; x++) {
                    this.maze[startY][x] = 0; // PATH
                }
                
                // 垂直路径
                for (let y = startY; y <= endY; y++) {
                    this.maze[y][endX] = 0; // PATH
                }
                
                // 确保起点和终点可达
                this.maze[startY][startX] = 2; // START
                this.maze[endY][endX] = 3; // END
                
                            console.log('起点到终点路径已确保');
            console.log('起点状态:', this.maze[startY][startX]);
            console.log('终点状态:', this.maze[endY][endX]);
        }
        
        // 移动玩家
        movePlayer(dx, dy) {
            const newX = this.player.x + dx;
            const newY = this.player.y + dy;
            
            console.log(`尝试移动: (${this.player.x}, ${this.player.y}) -> (${newX}, ${newY})`);
            
            // 检查边界
            if (newX < 0 || newX >= this.size || newY < 0 || newY >= this.size) {
                console.log('超出边界');
                return;
            }
            
            // 检查是否可以移动
            if (this.maze[newY][newX] !== 1) { // 不是墙壁
                this.player.x = newX;
                this.player.y = newY;
                console.log('移动成功，新位置:', this.player);
                
                // 更新玩家位置显示
                document.getElementById('player-pos').textContent = `(${this.player.x}, ${this.player.y})`;
                
                this.drawMaze();
                
                // 检查是否到达终点
                if (this.player.x === this.size - 2 && this.player.y === this.size - 2) {
                    console.log('恭喜通关！');
                    alert('恭喜通关！');
                }
            } else {
                console.log('无法移动：墙壁');
            }
        }
        
        // 移动到指定位置
        moveToPosition(x, y) {
            if (x < 0 || x >= this.size || y < 0 || y >= this.size) {
                return false;
            }
            
            if (this.maze[y][x] !== 1) { // 不是墙壁
                this.player.x = x;
                this.player.y = y;
                console.log('移动到新位置:', this.player);
                
                // 更新玩家位置显示
                document.getElementById('player-pos').textContent = `(${this.player.x}, ${this.player.y})`;
                
                this.drawMaze();
                
                // 检查是否到达终点
                if (this.player.x === this.size - 2 && this.player.y === this.size - 2) {
                    console.log('恭喜通关！');
                    alert('恭喜通关！');
                }
                
                return true;
            }
            return false;
        }
        
        // 获取鼠标在迷宫中的位置
        getMousePosition(event) {
            const rect = this.canvas.getBoundingClientRect();
            const x = Math.floor((event.clientX - rect.left) / (this.canvas.width / this.size));
            const y = Math.floor((event.clientY - rect.top) / (this.canvas.width / this.size));
            return { x, y };
        }
        
        // 初始化鼠标控制
        initMouseControl() {
            let isDragging = false;
            let dragStartPos = null;
            let dragPath = [];
            
            // 鼠标点击移动
            this.canvas.addEventListener('click', (e) => {
                const pos = this.getMousePosition(e);
                if (pos.x >= 0 && pos.x < this.size && pos.y >= 0 && pos.y < this.size) {
                    console.log(`鼠标点击位置: (${pos.x}, ${pos.y})`);
                    this.moveToPosition(pos.x, pos.y);
                }
            });
            
            // 鼠标按下开始拖拽
            this.canvas.addEventListener('mousedown', (e) => {
                const pos = this.getMousePosition(e);
                if (pos.x >= 0 && pos.x < this.size && pos.y >= 0 && pos.y < this.size) {
                    isDragging = true;
                    dragStartPos = { x: this.player.x, y: this.player.y };
                    dragPath = [];
                    console.log(`开始拖拽，起始位置: (${dragStartPos.x}, ${dragStartPos.y})`);
                }
            });
            
            // 鼠标移动时预览路径
            this.canvas.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const pos = this.getMousePosition(e);
                if (pos.x >= 0 && pos.x < this.size && pos.y >= 0 && pos.y < this.size) {
                    // 计算拖拽路径
                    dragPath = this.calculateDragPath(dragStartPos, pos);
                    this.drawMazeWithPath(dragPath);
                }
            });
            
            // 鼠标释放完成拖拽
            this.canvas.addEventListener('mouseup', (e) => {
                if (!isDragging) return;
                
                const pos = this.getMousePosition(e);
                if (pos.x >= 0 && pos.x < this.size && pos.y >= 0 && pos.y < this.size) {
                    console.log(`拖拽结束，目标位置: (${pos.x}, ${pos.y})`);
                    
                    // 尝试沿路径移动
                    if (this.moveAlongPath(dragPath)) {
                        console.log('拖拽移动成功');
                    } else {
                        console.log('拖拽移动失败，路径不可达');
                    }
                }
                
                isDragging = false;
                dragStartPos = null;
                dragPath = [];
                this.drawMaze(); // 清除路径预览
            });
            
            // 触摸设备支持
            this.canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const pos = this.getMousePosition(touch);
                if (pos.x >= 0 && pos.x < this.size && pos.y >= 0 && pos.y < this.size) {
                    isDragging = true;
                    dragStartPos = { x: this.player.x, y: this.player.y };
                    dragPath = [];
                }
            });
            
            this.canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!isDragging) return;
                
                const touch = e.touches[0];
                const pos = this.getMousePosition(touch);
                if (pos.x >= 0 && pos.x < this.size && pos.y >= 0 && pos.y < this.size) {
                    dragPath = this.calculateDragPath(dragStartPos, pos);
                    this.drawMazeWithPath(dragPath);
                }
            });
            
            this.canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (!isDragging) return;
                
                const touch = e.changedTouches[0];
                const pos = this.getMousePosition(touch);
                if (pos.x >= 0 && pos.x < this.size && pos.y >= 0 && pos.y < this.size) {
                    if (this.moveAlongPath(dragPath)) {
                        console.log('触摸拖拽移动成功');
                    }
                }
                
                isDragging = false;
                dragStartPos = null;
                dragPath = [];
                this.drawMaze();
            });
        }
        
        // 计算拖拽路径
        calculateDragPath(start, end) {
            const path = [];
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            
            // 使用直线路径（可以扩展为A*算法）
            if (Math.abs(dx) > Math.abs(dy)) {
                // 水平优先
                for (let x = start.x; x !== end.x; x += Math.sign(dx)) {
                    path.push({ x, y: start.y });
                }
                for (let y = start.y; y !== end.y; y += Math.sign(dy)) {
                    path.push({ x: end.x, y });
                }
            } else {
                // 垂直优先
                for (let y = start.y; y !== end.y; y += Math.sign(dy)) {
                    path.push({ x: start.x, y });
                }
                for (let x = start.x; x !== end.x; x += Math.sign(dx)) {
                    path.push({ x, y: end.y });
                }
            }
            
            path.push(end);
            return path;
        }
        
        // 沿路径移动
        moveAlongPath(path) {
            for (let i = 1; i < path.length; i++) {
                const pos = path[i];
                if (!this.moveToPosition(pos.x, pos.y)) {
                    return false; // 路径中断
                }
            }
            return true;
        }
        
        // 绘制迷宫和路径预览
        drawMazeWithPath(path) {
            this.drawMaze();
            
            // 绘制路径预览
            if (path.length > 0) {
                const cellSize = this.canvas.width / this.size;
                this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
                this.ctx.lineWidth = 3;
                this.ctx.lineCap = 'round';
                
                this.ctx.beginPath();
                for (let i = 0; i < path.length; i++) {
                    const pos = path[i];
                    const x = (pos.x + 0.5) * cellSize;
                    const y = (pos.y + 0.5) * cellSize;
                    
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();
            }
        }
            
            // 验证迷宫是否有解
            verifyMazeSolvability() {
                const start = {x: 1, y: 1};
                const end = {x: this.size - 2, y: this.size - 2};
                
                // 使用BFS检查路径是否存在
                const visited = new Set();
                const queue = [start];
                visited.add(`${start.x},${start.y}`);
                
                const directions = [
                    {dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: 0, dy: 1}, {dx: -1, dy: 0}
                ];
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    
                    // 检查是否到达终点
                    if (current.x === end.x && current.y === end.y) {
                        return true;
                    }
                    
                    // 检查四个方向
                    for (const dir of directions) {
                        const nx = current.x + dir.dx;
                        const ny = current.y + dir.dy;
                        const key = `${nx},${ny}`;
                        
                        if (nx >= 0 && nx < this.size && ny >= 0 && ny < this.size && 
                            !visited.has(key) && this.maze[ny][nx] !== 1) {
                            visited.add(key);
                            queue.push({x: nx, y: ny});
                        }
                    }
                }
                
                return false;
            }
            
            // 备用迷宫生成算法（保证有解）
            generateFallbackMaze() {
                console.log('使用备用迷宫生成算法');
                
                // 重置迷宫
                this.maze = Array(this.size).fill().map(() => Array(this.size).fill(1));
                
                // 创建一条从起点到终点的基本路径
                this.createSimplePath();
                
                // 设置起点和终点
                this.maze[1][1] = 2; // START
                this.maze[this.size - 2][this.size - 2] = 3; // END
            }
            
            // 创建简单路径
            createSimplePath() {
                // 创建一条L形路径
                for (let i = 1; i < this.size - 1; i++) {
                    this.maze[1][i] = 0; // PATH
                }
                for (let i = 1; i < this.size - 1; i++) {
                    this.maze[i][this.size - 2] = 0; // PATH
                }
                
                // 添加一些随机分支
                const branchCount = Math.floor(this.size / 4);
                for (let i = 0; i < branchCount; i++) {
                    const x = 1 + Math.floor(Math.random() * (this.size - 2));
                    const y = 1 + Math.floor(Math.random() * (this.size - 2));
                    
                    if (this.maze[y][x] === 1) { // WALL
                        const directions = [
                            {dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: 0, dy: 1}, {dx: -1, dy: 0}
                        ];
                        
                        for (const dir of directions) {
                            const nx = x + dir.dx;
                            const ny = y + dir.dy;
                            
                            if (nx > 0 && nx < this.size - 1 && ny > 0 && ny < this.size - 1 &&
                                this.maze[ny][nx] === 0) {
                                this.maze[y][x] = 0; // PATH
                                break;
                            }
                        }
                    }
                }
            }

            generateDFS() {
                const stack = [{x: 1, y: 1}];
                this.maze[1][1] = 0; // PATH
                
                const directions = [
                    {dx: 0, dy: -2}, {dx: 2, dy: 0}, {dx: 0, dy: 2}, {dx: -2, dy: 0}
                ];
                
                let iterations = 0;
                const maxIterations = this.size * this.size * 2;
                
                while (stack.length > 0 && iterations < maxIterations) {
                    iterations++;
                    
                    const current = stack[stack.length - 1];
                    const shuffledDirections = [...directions].sort(() => Math.random() - 0.5);
                    let found = false;
                    
                    for (const dir of shuffledDirections) {
                        const nx = current.x + dir.dx;
                        const ny = current.y + dir.dy;
                        
                        if (nx >= 0 && nx < this.size && ny >= 0 && ny < this.size && 
                            this.maze[ny][nx] === 1) {
                            this.maze[nx][ny] = 0;
                            this.maze[(current.x + nx) / 2][(current.y + ny) / 2] = 0;
                            stack.push({x: nx, y: ny});
                            found = true;
                            break;
                        }
                    }
                    
                    if (!found) {
                        stack.pop();
                    }
                }
                
                if (iterations >= maxIterations) {
                    console.warn('DFS算法达到最大迭代次数');
                }
            }

            drawMaze() {
                const cellSize = this.canvas.width / this.size;
                
                // 清空画布
                this.ctx.fillStyle = '#f0f0f0';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // 绘制迷宫
                for (let y = 0; y < this.size; y++) {
                    for (let x = 0; x < this.size; x++) {
                        const cell = this.maze[y][x];
                        const px = x * cellSize;
                        const py = y * cellSize;
                        
                        if (cell === 1) { // WALL
                            this.ctx.fillStyle = '#333';
                            this.ctx.fillRect(px, py, cellSize, cellSize);
                        } else if (cell === 2) { // START
                            this.ctx.fillStyle = '#4CAF50';
                            this.ctx.fillRect(px, py, cellSize, cellSize);
                        } else if (cell === 3) { // END
                            this.ctx.fillStyle = '#F44336';
                            this.ctx.fillRect(px, py, cellSize, cellSize);
                        }
                    }
                }
                
                // 绘制网格
                this.ctx.strokeStyle = '#ccc';
                this.ctx.lineWidth = 1;
                for (let i = 0; i <= this.size; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i * cellSize, 0);
                    this.ctx.lineTo(i * cellSize, this.canvas.height);
                    this.ctx.stroke();
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, i * cellSize);
                    this.ctx.lineTo(this.canvas.width, i * cellSize);
                    this.ctx.stroke();
                }
                
                // 绘制玩家
                const playerX = this.player.x * cellSize;
                const playerY = this.player.y * cellSize;
                this.ctx.fillStyle = '#2196F3';
                this.ctx.fillRect(playerX, playerY, cellSize, cellSize);
                
                // 绘制玩家边框
                this.ctx.strokeStyle = '#1976D2';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(playerX, playerY, cellSize, cellSize);
            }

            generateWithTimeout() {
                const btn = document.getElementById('generate-btn');
                const originalText = btn.textContent;
                btn.textContent = '生成中...';
                btn.disabled = true;
                
                const status = document.getElementById('status');
                status.textContent = '开始生成迷宫...';
                status.className = 'status warning';
                
                // 设置超时保护
                this.generationTimeout = setTimeout(() => {
                    status.textContent = '迷宫生成超时！请选择较小的迷宫尺寸。';
                    status.className = 'status error';
                    btn.textContent = originalText;
                    btn.disabled = false;
                }, this.maxGenerationTime);
                
                // 使用requestAnimationFrame避免阻塞UI
                requestAnimationFrame(() => {
                    try {
                        const startTime = Date.now();
                        this.generateMaze();
                        const endTime = Date.now();
                        
                        // 清除超时
                        if (this.generationTimeout) {
                            clearTimeout(this.generationTimeout);
                            this.generationTimeout = null;
                        }
                        
                        // 验证迷宫是否有解
                        if (mazeGenerator.verifyMazeSolvability()) {
                            status.textContent = `迷宫生成成功！耗时: ${endTime - startTime}ms，迷宫有解`;
                            status.className = 'status success';
                        } else {
                            status.textContent = `迷宫生成完成，但可能无解，耗时: ${endTime - startTime}ms`;
                            status.className = 'status warning';
                        }
                        
                    } catch (error) {
                        console.error('迷宫生成错误:', error);
                        status.textContent = '迷宫生成失败: ' + error.message;
                        status.className = 'status error';
                    } finally {
                        btn.textContent = originalText;
                        btn.disabled = false;
                    }
                });
            }
        }

        // 初始化测试
        const mazeGenerator = new SimpleMazeGenerator();
        mazeGenerator.init();
        
        // 初始化鼠标控制
        mazeGenerator.initMouseControl();

        // 事件监听
        document.getElementById('generate-btn').addEventListener('click', () => {
            mazeGenerator.size = parseInt(document.getElementById('maze-size').value);
            mazeGenerator.generateWithTimeout();
        });

        document.getElementById('test-large-btn').addEventListener('click', () => {
            mazeGenerator.size = 35;
            document.getElementById('maze-size').value = 35;
            mazeGenerator.generateWithTimeout();
        });

        document.getElementById('test-complex-btn').addEventListener('click', () => {
            mazeGenerator.size = 31;
            document.getElementById('maze-size').value = 31;
            document.getElementById('maze-complexity').value = 'complex';
            mazeGenerator.generateWithTimeout();
        });

        // 自动生成一个初始迷宫
        setTimeout(() => {
            mazeGenerator.generateMaze();
        }, 100);
        
        // 添加键盘控制
        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'ArrowUp':
                case 'KeyW':
                    mazeGenerator.movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    mazeGenerator.movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    mazeGenerator.movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    mazeGenerator.movePlayer(1, 0);
                    break;
            }
        });
    </script>
</body>
</html>
